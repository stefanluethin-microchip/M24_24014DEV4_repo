#!/usr/bin/env groovy

// This file was generated by the CI/CD Wizard version 1.2.19.
// See the user guide for information on how to customize and use this file.

pipeline {
    environment {
        BUILD_CONFIGURATION = 'samd21xplp'
        SUPPORT_SCRIPT_REPO = 'https://raw.githubusercontent.com/MicrochipTech/cicd-assistant/main'
        SIMULATE_BUILD_CONFIGURATION = 'samd21xplp'
        SIMULATE_COVERAGE_DIR = 'simulator-coverage'
        SIMULATE_COVERAGE_XML = 'simulator-coverage.xml'
        SIMULATE_RESULT_JUNIT = 'simulate-junit.xml'
        HARDWARE_TEST_BUILD_CONFIGURATION = 'samd21xplp'
        HARDWARE_TEST_RESULT_JUNIT = 'hw-test-junit.xml'
        HARDWARE_TEST_SERIAL_OUTPUT_FILE = 'hardware_test_serial_output.txt'
        HARDWARE_TEST_COVERAGE_DIR = 'hardware_test_coverage'
    }

    // Build orchestrator job can run on any available agent
    // Use --build-agent-label with generate-jenkins to specify
    // a label to restrict agents
    agent any

    stages {
        // The build step will build the source code using the
        // selected compiler to verify that it builds correctly,
        // and store the build artefacts for later use
        stage('Build') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            steps {
                sh(
                    label: 'Generate build makefiles',
                    script: "prjMakefilesGenerator.sh -v -f ./@${env.BUILD_CONFIGURATION}"
                )
                sh(
                    label: 'Running Makefile',
                    script: """
                            rm -rf ./build
                            rm -rf ./dist
                            make clean
                            make CONF=${env.BUILD_CONFIGURATION}
                            """
                )

                // Store build artefacts for later
                stash name: 'build',
                      includes: 'dist/**/*',
                      allowEmpty: true
            }
        }
        // The analyse step will run static analysis on the
        // source code using the MISRA analysis tool and
        // store the findings in a xml report file for later
        stage('Analyse') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            steps {
                sh(
                    label: 'Running MISRA Analysis',
                    script: """
                            rm -rf cppcheck-result.xml
                            misracli.sh --xml cppcheck-result.xml ./ || true
                            """
                )

                // Store analyse artefacts for later
                stash name: 'analyse',
                      includes: 'cppcheck-result.xml',
                      allowEmpty: true
            }
        }
        // The simulate step will retrieve the build artefacts from the build step
        // and run a test suite from the binary in a simulator.
        // Test results and coverage will be collected and stored for later.
        stage('Simulate') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            environment {
                SIMULATE_MDB_SCRIPT_FILE = 'mdb-simulator-script.txt'
                SIMULATE_BINARY_FILE = './dist/build.elf'
                SIMULATE_SERIAL_OUTPUT_FILE = 'sercom_output.txt'
                SIMULATE_COVERAGE_FILE = 'simulator-coverage.txt'
            }
            steps {
                // Retrieve build artefacts from build step
                sh(
                    label: 'Remove possible local dist dir before unstashing build',
                    script: """
                            rm -rf ./dist
                            """
                )
                unstash 'build'
                // Run binary in simulator
                sh(
                    label: 'Copy binary file to location expected by MDB script',
                    script: """
                            rm -rf ${env.SIMULATE_BINARY_FILE}
                            rm -rf ${env.SIMULATE_SERIAL_OUTPUT_FILE}
                            cp ./dist/**/**/*.elf ${env.SIMULATE_BINARY_FILE}
                            """
                )
                sh(
                    label: 'Run MDB script on simulator',
                    script: """
                            mdb.sh ${env.SIMULATE_MDB_SCRIPT_FILE}
                            rm -rf ${env.SIMULATE_BINARY_FILE}
                            """
                )
                // Collect unity test results from serial output
                // and convert test data to junit format
                sh(
                    label: 'Convert serial output to junit test result (xml)',
                    script: """
                            if [ -f "${env.SIMULATE_SERIAL_OUTPUT_FILE}" ]; then
                                echo "Serial communication captured during simulation (raw):"
                                cat ${env.SIMULATE_SERIAL_OUTPUT_FILE}

                                curl ${env.SUPPORT_SCRIPT_REPO}/unity2junit.js -o unity2junit.js
                                rm -rf ${env.SIMULATE_RESULT_JUNIT}
                                node unity2junit.js ${env.SIMULATE_SERIAL_OUTPUT_FILE} ${env.SIMULATE_RESULT_JUNIT}
                            else
                                echo "Warning: The simulation did not generate any serial output file"
                            fi
                            """
                )
                // Collect coverage data from simulator and
                // convert data to gcov format
                sh(
                    label: 'Convert simulator coverage to xml and html using gcov / gcovr',
                    script: """
                            if [ -f "${env.SIMULATE_COVERAGE_FILE}" ]; then
                                curl ${env.SUPPORT_SCRIPT_REPO}/simcov2gcov.js -o simcov2gcov.js
                                node simcov2gcov.js ${env.SIMULATE_COVERAGE_FILE} .

                                rm -rf ${env.SIMULATE_COVERAGE_DIR}
                                mkdir  ${env.SIMULATE_COVERAGE_DIR}
                                gcovr --use-gcov-files --keep --print-summary --xml --output ${env.SIMULATE_COVERAGE_XML} -r .
                                gcovr --use-gcov-files --keep --print-summary --html --html-details --output  ${env.SIMULATE_COVERAGE_DIR}/index.html -r .
                            else
                                echo "Warning: The simulation did not generate any coverage data"
                            fi
                            """
                )

                // Store simulate artefacts for later
                stash name: 'simulate',
                      includes: "${env.SIMULATE_COVERAGE_DIR}/**/*,${env.SIMULATE_COVERAGE_XML},${env.SIMULATE_RESULT_JUNIT}",
                      allowEmpty: true
            }
        }
        stage('Hardware Test') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            environment {
                HARDWARE_TEST_TOOL_IP = '10.162.178.23'
                HARDWARE_TEST_TOOL_SERIAL_PORT = '5050'
                HARDWARE_TEST_MDB_SCRIPT_FILE = 'mdb-hardware-script.txt'
                HARDWARE_TEST_BINARY_FILE = './dist/build.elf'
            }
            steps {
                sh(
                    label: 'Generate hardware test makefiles',
                    script: "prjMakefilesGenerator.sh -v -f ./@${env.HARDWARE_TEST_BUILD_CONFIGURATION}"
                )
                sh(
                    label: 'Running Makefile',
                    script: """
                            rm -rf ./build
                            rm -rf ./dist
                            make clean
                            make CONF=${env.HARDWARE_TEST_BUILD_CONFIGURATION}
                            """
                )
                sh(
                    label: 'Copy binary file to location expected by MDB script',
                    script: """
                            rm -rf ${env.HARDWARE_TEST_BINARY_FILE}
                            cp ./dist/**/**/*.elf ${env.HARDWARE_TEST_BINARY_FILE}
                            """
                )
                sh(
                    label: 'Start capturing serial output',
                    script: """
                            curl ${env.SUPPORT_SCRIPT_REPO}/socket2file.js -o socket2file.js
                            rm -rf ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}
                            node socket2file.js ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE} \
                            ${env.HARDWARE_TEST_TOOL_IP} ${env.HARDWARE_TEST_TOOL_SERIAL_PORT} &
                            """
                )
                sh(
                    label: 'Run MDB script on hardware',
                    script: """
                            mdb.sh ${env.HARDWARE_TEST_MDB_SCRIPT_FILE}
                            rm -rf ${env.HARDWARE_TEST_BINARY_FILE}
                            """
                )
                sh(
                    label: 'End capturing serial output',
                    script: """
                            pkill -f "node socket2file.js"
                            """
                )
                sh(
                    label: 'Convert serial output to junit test result (xml)',
                    script: """
                            if [ -f "${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}" ]; then
                                echo "Serial communication captured during hardware test (raw):"
                                cat ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}

                                curl ${env.SUPPORT_SCRIPT_REPO}/unity2junit.js -o unity2junit.js
                                rm -rf ${env.HARDWARE_TEST_RESULT_JUNIT}
                                node unity2junit.js ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE} ${env.HARDWARE_TEST_RESULT_JUNIT}
                            else
                                echo "Warning: The hardware test did not generate any serial output file"
                            fi
                            """
                )

                // Store hardware test artefacts for later
                stash name: 'hardware_test',
                      includes: "${env.HARDWARE_TEST_RESULT_JUNIT}, ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}, ${env.HARDWARE_TEST_COVERAGE_DIR}/**/*",
                      allowEmpty: true
            }
        }
        // Generate doxygen based documentation
        // and store the artefacts for later
        stage('Documentation') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            steps {
                sh(
                    label: 'Generate Doxygen documentation',
                    script: """
                            [ -f Doxyfile ] || doxygen -g Doxyfile
                            doxygen Doxyfile
                            """
                )
                dir("latex") {
                    sh(
                        label: 'Pdf',
                        script: """
                                make pdf
                                """
                    )
                }

                // Store documentation artefacts for later
                stash name: 'doxygen',
                      includes: 'html/**/*,latex/**/*',
                      allowEmpty: true
            }
        }
        stage('Publish') {
            steps {
                // Retrieve build artefacts
                unstash 'build'
                dir('dist') {
                    zip archive: true,
                        glob: '**/*',
                        overwrite: true,
                        zipFile: 'dist.zip'
                }
                // Retrieve documentation artefacts
                unstash 'doxygen'
                dir('html') {
                    zip archive: true,
                        glob: '**/*',
                        overwrite: true,
                        zipFile: 'doc-html.zip'
                }
                dir('latex') {
                    zip archive: true,
                        glob: '**/*',
                        exclude: '*.pdf',
                        overwrite: true,
                        zipFile: 'doc-latex.zip'
                    zip archive: true,
                        glob: '**/*.pdf',
                        overwrite: true,
                        zipFile: 'doc-pdf.zip'
                }
                // Retrieve simulate artefacts
                unstash 'simulate'
                // Publish junit test results
                junit allowEmptyResults: true,
                      testResults: "${env.SIMULATE_RESULT_JUNIT}"
                // Publish a zip file with coverage in html
                zip archive: true,
                    glob: "${env.SIMULATE_COVERAGE_DIR}/**/*",
                    overwrite: true,
                    zipFile: 'simulator-coverage-html.zip'
                // Publish coverage using cobertura xml adapter
                publishCoverage adapters: [
                                    istanbulCoberturaAdapter("${env.SIMULATE_COVERAGE_XML}")
                                ],
                                failNoReports: false,
                                sourceFileResolver: sourceFiles('NEVER_STORE')
                // Retrieve hardware test artefacts
                unstash 'hardware_test'
                // Publish junit test results
                junit allowEmptyResults: true,
                      testResults: "${env.HARDWARE_TEST_RESULT_JUNIT}"
                // Publish serial output
                archiveArtifacts artifacts: "${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}"
                // Publish a zip file with coverage in html
                zip archive: true,
                    glob: "${env.HARDWARE_TEST_COVERAGE_DIR}/**/*",
                    overwrite: true,
                    zipFile: 'hardware-test-coverage-html.zip'
                
                // Retrieve analyse artefacts
                unstash 'analyse'
                recordIssues(tools: [
                    cppCheck(pattern: 'cppcheck-result.xml', reportEncoding: 'ISO-8859-1'),
                    gcc()
                ])
            }
        }
    }
    post {
        // Optional: Add post build actions for various build outcomes.
        // NOTE: The order in which post build actions is executed
        // is fixed (always, changed, success, unstable, failure)
        // regardless of how they appear below.

        // Actions to perform regardless of outcome
        always {
            // Clean workspace after build
            cleanWs()
        }

        // changed { /* Actions to perform when outcome state was changed since last build */ }
        // success { /* Actions to perform for builds that succeed */ }
        // unstable { /* Actions to perform for builds marked as unstable */ }
        // failure { /* Actions to perform for failed builds */ }
    }
}
